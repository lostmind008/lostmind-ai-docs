<Info>
This content was automatically extracted from LostMindAI-TurboRepo.
For the most up-to-date information, refer to the source project.
</Info>

# Architecture Decision Records (ADRs)

> **[ðŸ“š Documentation Hub](../README.md)** | **[ðŸ  Main README](../../README.md)** | **[ðŸŽ¯ Master Plan](lostmind-master-plan.md)** | **[ðŸ—“ï¸ Implementation Roadmap](implementation-roadmap.md)**

## ADR-001: Next.js 15 with App Router

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Need to select the primary framework for web applications and API endpoints, considering developer experience, performance, and future scalability.

### Decision
Adopt Next.js 15 with App Router as the primary framework for all user-facing applications and most API endpoints.

### Alternatives Considered
1. **Next.js 14**: Stable but missing key improvements
2. **Pure FastAPI**: All Python, poor frontend DX
3. **Remix**: Good but smaller ecosystem
4. **SvelteKit**: Excellent performance but limited team expertise

### Consequences
**Positive**:
- React 19 support with future-proofing
- Uncached by default (better for dynamic SaaS)
- Improved build performance with stable Turbopack
- Enhanced TypeScript support
- Server Components and Actions reduce client bundle

**Negative**:
- Breaking changes from Next.js 14
- React 19 may have minor issues
- Team needs training on App Router patterns

---

## ADR-002: Turborepo for Monorepo Management

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Multiple repositories causing duplicated tooling, inconsistent dependencies, and slow CI pipelines. Need unified build system.

### Decision
Use Turborepo for monorepo management with pnpm workspaces.

### Alternatives Considered
1. **Nx**: More features but higher complexity
2. **Lerna**: Legacy, less maintained
3. **Rush**: Microsoft's tool, complex setup
4. **Bazel**: Powerful but steep learning curve

### Consequences
**Positive**:
- Simple configuration
- Built-in remote caching
- Excellent TypeScript/JavaScript support
- Vercel ecosystem integration
- Fast incremental builds

**Negative**:
- Limited polyglot support
- Less mature than Nx
- May need migration if adding Go/Rust services

**Migration Trigger**: Consider Nx when team >10 developers or Python services >30% of codebase

---

## ADR-003: PostgreSQL with RLS for Multi-tenancy

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Multi-tenant SaaS requiring secure data isolation with good performance and operational simplicity.

### Decision
PostgreSQL with Row Level Security (RLS) policies, application validation, and comprehensive audit logging.

### Implementation
```sql
-- Enable RLS on tables
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Create tenant isolation policy
CREATE POLICY tenant_isolation ON documents 
  FOR ALL TO authenticated 
  USING (tenant_id = current_setting('app.tenant_id')::uuid);
```

### Alternatives Considered
1. **Separate databases per tenant**: Maximum isolation, complex ops
2. **Schema per tenant**: Good isolation, moderate complexity
3. **Application-only isolation**: Simple but less secure

### Consequences
**Positive**:
- Database-level security enforcement
- Single database simplifies operations
- Cost-effective at small-medium scale
- Good performance with proper indexing

**Negative**:
- Performance impact at massive scale
- Complex RLS policy management
- Potential for policy bypass if misconfigured

---

## ADR-004: Google Generative AI with Provider Abstraction

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Primary AI provider selection while maintaining flexibility for future changes and avoiding vendor lock-in.

### Decision
Google Generative AI SDK as primary with abstraction layer for provider swapping.

### Implementation
```typescript
interface AIProvider {
  generateText(prompt: string): Promise<string>
  embedDocument(content: string): Promise<number[]>
  searchRAG(query: string): Promise<Result[]>
}

class GoogleAIProvider implements AIProvider { }
class OpenAIProvider implements AIProvider { }
```

### Alternatives Considered
1. **OpenAI only**: Excellent API, expensive
2. **Anthropic only**: High quality, limited models
3. **Multi-provider from start**: Complex overhead

### Consequences
**Positive**:
- Cost-effective with Google's pricing
- Strong multimodal capabilities
- Gemini 2.0 Flash for speed
- Future-proof abstraction

**Negative**:
- Initial abstraction overhead
- Google ecosystem dependency
- Multiple adapter maintenance

---

## ADR-005: Hybrid Deployment Strategy

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Different workload types require different execution environments for optimal cost and performance.

### Decision
- **Vercel**: Next.js apps and APIs <2 second response
- **Google Cloud Run**: FastAPI services for heavy compute
- **Pub/Sub**: Async task orchestration

### Deployment Matrix
| Workload Type | Platform | Reason |
|---------------|----------|---------|
| Web UI | Vercel | Edge distribution, SSR |
| CRUD APIs | Vercel | Fast cold starts |
| Document Processing | Cloud Run | Long execution time |
| ML Inference | Cloud Run | Python dependencies |
| Background Jobs | Cloud Run + Pub/Sub | Async processing |

### Consequences
**Positive**:
- Optimal cost per workload type
- Best-in-class developer experience
- Auto-scaling on both platforms
- Global edge distribution

**Negative**:
- Multiple platform management
- Cross-platform networking
- Different monitoring systems

---

## ADR-006: Stripe for Unified Billing

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Multiple apps need unified billing with support for subscriptions, usage-based pricing, and credit systems.

### Decision
Stripe Billing with shared `@lostmind/billing` package across all apps.

### Implementation Architecture
```typescript
// Shared billing package
@lostmind/billing/
  â”œâ”€â”€ subscriptions/     # Plan management
  â”œâ”€â”€ usage/            # Metered billing
  â”œâ”€â”€ credits/          # Credit system
  â”œâ”€â”€ webhooks/         # Event handlers
  â””â”€â”€ portal/           # Customer portal
```

### Consequences
**Positive**:
- Unified customer experience
- Flexible pricing models
- Strong compliance (SCA, PCI)
- Comprehensive webhooks

**Negative**:
- 2.9% + 30Â¢ transaction fees
- Vendor lock-in risk
- Complex usage metering

---

## ADR-007: Event-Driven Background Processing

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Long-running tasks (document processing, web crawling) exceed typical HTTP timeout limits.

### Decision
Google Cloud Pub/Sub for event messaging with Cloud Run subscribers.

### Flow
1. Next.js API enqueues message
2. Pub/Sub delivers to Cloud Run
3. FastAPI processes asynchronously
4. Results stored in database
5. Optional webhook callback

### Alternatives Considered
1. **Redis Streams**: Good but requires management
2. **RabbitMQ**: Complex for our needs
3. **AWS SQS**: Would split infrastructure

### Consequences
**Positive**:
- Fully managed service
- At-least-once delivery
- Dead letter queues
- Automatic retries

**Negative**:
- GCP dependency
- Message ordering complexity
- Debugging distributed systems

---

## ADR-008: Observability Stack

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Distributed architecture requires unified observability across Vercel and Google Cloud.

### Decision
Start with structured logging, add APM tool when budget allows.

### Implementation Phases
**Phase 1 (MVP)**:
- Structured JSON logging
- Trace ID propagation
- Basic metrics

**Phase 2 (Growth)**:
- Datadog/New Relic integration
- Distributed tracing
- Custom dashboards

### Trace ID Pattern
```typescript
// Generate in Next.js
const traceId = crypto.randomUUID()

// Propagate to FastAPI
headers: { 'X-Trace-ID': traceId }

// Log with trace ID
logger.info({ traceId, message: 'Processing request' })
```

---

## ADR-009: Database Migration Strategy

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Serverless environments cannot safely run migrations during cold starts.

### Decision
Run Prisma migrations in CI/CD pipeline before deployment.

### Pipeline Order
1. Run tests
2. Build applications
3. **Run migrations** (prisma migrate deploy)
4. Deploy Next.js to Vercel
5. Deploy FastAPI to Cloud Run

### Rollback Strategy
- Keep migration history
- Test rollback procedures
- Blue-green deployments for critical changes

---

## ADR-010: Testing Strategy

**Date**: 2025-09-02  
**Status**: Accepted  
**Deciders**: LostMind AI Technical Team  

### Context
Monorepo requires comprehensive testing across packages and apps.

### Decision
Layered testing approach with automation.

### Test Pyramid
```
         /\
        /E2E\      (5%) - Critical user flows
       /------\
      /  Integ  \   (20%) - API contracts
     /------------\
    /   Unit Tests  \ (75%) - Business logic
   /------------------\
```

### Tools
- **Unit**: Vitest (fast, ESM support)
- **Integration**: Supertest + Playwright
- **E2E**: Playwright
- **Coverage**: 80% target

---

## Template for Future ADRs

```markdown
## ADR-XXX: [Decision Title]

**Date**: YYYY-MM-DD  
**Status**: [Proposed | Accepted | Deprecated | Superseded]  
**Deciders**: [List of people involved]  

### Context
[Problem requiring decision]

### Decision
[Chosen solution]

### Alternatives Considered
1. **Option 1**: [Why not chosen]
2. **Option 2**: [Why not chosen]

### Consequences
**Positive**:
- [Benefits]

**Negative**:
- [Trade-offs]

**Mitigation**:
- [How to address negatives]

### Review Date
[When to revisit this decision]
```

---

## Review Schedule
- Monthly ADR review sessions
- Quarterly architecture health checks
- Annual technology assessment
- Ad-hoc reviews for issues

## Decision Criteria for New ADRs
- Affects multiple apps/packages
- Technology stack changes
- Security/compliance impacts
- Significant refactoring
- External service integrations
- Database schema changes